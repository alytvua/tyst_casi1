<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Plinko — Rapier Physics (Web)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f172a;overflow:hidden}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
      font:600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#e8eefb;z-index:10}
    .btn{background:#1a2333;color:#e8eefb;border:1px solid #2b3d5c;padding:10px 14px;border-radius:12px;cursor:pointer}
    .tag{padding:8px 12px;border-radius:999px;background:#121a27;border:1px solid #2b3d5c}
    .legend{display:flex;gap:8px;align-items:center}
    .dot{width:14px;height:14px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    #seed{width:140px;background:#0f1624;color:#e8eefb;border:1px solid #2b3d5c;border-radius:10px;padding:9px 10px}
    #hud{position:fixed;right:12px;top:12px;z-index:11;color:#e8eefb;font:600 14px/1.35 ui-sans-serif,system-ui,Segoe UI,Roboto}
    .card{background:#0f1624cc;border:1px solid #2b3d5c;padding:10px 12px;border-radius:12px;min-width:240px}
    .row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .swatch{width:12px;height:12px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    .muted{opacity:.75;font-weight:500}
  </style>
</head>
<body>
  <div id="hud" class="card">
    <div class="row"><strong>Leaderboard</strong></div>
    <div id="lb"></div>
    <div class="row muted">In progress: <span id="left">0</span></div>
  </div>

  <div id="ui">
    <button id="drop" class="btn">Drop 10 Balls</button>
    <button id="reset" class="btn">Reset</button>
    <span class="tag">Tilt: <span id="tiltVal">12°</span></span>
    <input id="seed" placeholder="seed (optional)" />
    <div class="legend tag">
      <span>Bet:</span>
      <span class="dot" style="background:#ff4d4d"></span><span>Red</span>
      <span class="dot" style="background:#5dd9ff"></span><span>Blue</span>
      <span class="dot" style="background:#7cff6b"></span><span>Green</span>
      <span class="dot" style="background:#ffd166"></span><span>Yellow</span>
      <span class="dot" style="background:#d291ff"></span><span>Purple</span>
    </div>
  </div>

  <!-- Three (глобально), OrbitControls (глобально для r149), Rapier (UMD, без модулей) -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/@dimforge/rapier3d-compat@0.14.0/rapier3d-compat.min.js"></script>

  <script>
    (function(){
      // ---------- Constants ----------
      const boardW = 14, boardH = 22;
      const tiltDeg = 12;
      const deg2rad = d => d * Math.PI / 180;

      const colors = [0xff4d4d, 0x5dd9ff, 0x7cff6b, 0xffd166, 0xd291ff];
      const colorName = { [0xff4d4d]:'Red', [0x5dd9ff]:'Blue', [0x7cff6b]:'Green', [0xffd166]:'Yellow', [0xd291ff]:'Purple' };

      // ---------- Three.js ----------
      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0f172a, 1);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 300);
      camera.position.set(0, 36, 28);
      let controls = null;
      if (typeof THREE.OrbitControls === 'function'){
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.enablePan = false;
        controls.minDistance = 24; controls.maxDistance = 50;
        controls.minPolarAngle = THREE.Math.degToRad(30);
        controls.maxPolarAngle = THREE.Math.degToRad(65);
        controls.target.set(0,0,0); controls.update();
      } else {
        camera.lookAt(0,0,0);
      }

      scene.add(new THREE.AmbientLight(0xffffff, 0.35));
      const key = new THREE.DirectionalLight(0xffffff, 1.15);
      key.position.set(12, 26, 12); key.castShadow = true; key.shadow.mapSize.set(2048,2048);
      scene.add(key);
      const rim = new THREE.DirectionalLight(0x9bbcff, 0.5);
      rim.position.set(-10, 18, -12); scene.add(rim);

      // Board visual
      const board = new THREE.Mesh(
        new THREE.PlaneGeometry(boardW, boardH),
        new THREE.MeshStandardMaterial({ color:0x263043, metalness:0.25, roughness:0.55, emissive:0x0b1120, emissiveIntensity:0.15 })
      );
      board.rotation.x = -Math.PI/2;
      board.receiveShadow = true;
      scene.add(board);

      document.getElementById('tiltVal').textContent = tiltDeg + "°";

      // Finish line visual
      const slotZ = -boardH/2 + 0.6;
      const finishZ = slotZ - 0.25;
      const fGeo = new THREE.BoxGeometry(boardW-0.6, 0.05, 0.02);
      const fMat = new THREE.MeshBasicMaterial({ color:0x29ff89 });
      const finishLine = new THREE.Mesh(fGeo, fMat);
      finishLine.position.set(0, 0.51, finishZ);
      scene.add(finishLine);

      // Frame walls (visible)
      function addFrameWall(x, z, w, t, rotY=0, h=2.4){
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(w, h, t),
          new THREE.MeshStandardMaterial({ color:0x1b2436, metalness:0.3, roughness:0.45 })
        );
        mesh.position.set(x, h/2, z); mesh.rotation.y=rotY;
        mesh.castShadow = mesh.receiveShadow = true;
        scene.add(mesh);
      }
      addFrameWall( 0,  boardH/2-0.2, boardW, 0.6, 0, 2.4);
      addFrameWall( 0, -boardH/2+0.2, boardW, 0.6, 0, 2.4);
      addFrameWall(-boardW/2+0.2, 0, boardH, 0.6, Math.PI/2, 2.4);
      addFrameWall( boardW/2-0.2, 0, boardH, 0.6, Math.PI/2, 2.4);

      // Pins visuals (cylinders)
      const pinR_draw = 0.19, pinH = 0.62;
      const pinGeo = new THREE.CylinderGeometry(pinR_draw, pinR_draw, pinH, 20);
      const pinMat = new THREE.MeshStandardMaterial({ color:0x2f3b59, metalness:0.6, roughness:0.35 });
      const rowGap = 1.0, colGap = 1.0, rows = 14;
      for (let r=0; r<rows; r++){
        const cols = Math.floor(boardW/colGap)+1;
        for (let c=0; c<cols; c++){
          const offset = (r%2===0)?0:colGap/2;
          const x = -boardW/2 + offset + c*colGap;
          const z = boardH/2 - 2 - r*rowGap;
          const y = pinH/2;
          const m = new THREE.Mesh(pinGeo, pinMat);
          m.position.set(x,y,z); m.castShadow=m.receiveShadow=true;
          scene.add(m);
        }
      }

      // Slot dividers visuals
      const slotCount = 7;
      const slotWidth = boardW / slotCount;
      for (let s=0; s<=slotCount; s++){
        const x = -boardW/2 + s*slotWidth;
        addFrameWall(x, slotZ, 0.34, 0.6, Math.PI/2, 1.6);
      }
      // Catcher visual (floor)
      (function addCatcherVisual(){
        const depth = 3.2, h=0.24;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(boardW-0.5, h, depth),
          new THREE.MeshStandardMaterial({ color:0x1a2234, metalness:0.2, roughness:0.6 }));
        mesh.position.set(0, h/2, slotZ - depth/2 - 0.05);
        mesh.castShadow = mesh.receiveShadow = true;
        scene.add(mesh);
      })();

      // ---------- Rapier ----------
      let world = null;
      const balls = []; // {id, rb, radius, mesh, color, finished, prevZ}
      let nextId = 1;
      let startTime = 0;
      const finished = [];
      const lbEl = document.getElementById('lb');
      const leftEl = document.getElementById('left');

      function renderLB(){
        lbEl.innerHTML = '';
        finished.sort((a,b)=>a.tSec-b.tSec).forEach((e,i)=>{
          const row = document.createElement('div');
          row.className='row';
          row.innerHTML=`<span>${i+1}.</span>
            <span class="swatch" style="background:#${e.color.toString(16).padStart(6,'0')}"></span>
            <span>${colorName[e.color]||('#'+e.color.toString(16))}</span>
            <span class="muted">${e.tSec.toFixed(2)}s</span>`;
          lbEl.appendChild(row);
        });
        leftEl.textContent = balls.filter(b=>!b.finished).length;
      }

      function quatFromEuler(rx, ry, rz){
        const qx = RAPIER.Quaternion.fromEuler(rx, 0, 0);
        const qy = RAPIER.Quaternion.fromEuler(0, ry, 0);
        const qz = RAPIER.Quaternion.fromEuler(0, 0, rz);
        return qz.mul(qy).mul(qx);
      }

      function makeWorld(){
        world = new RAPIER.World({ x:0, y:-9.82, z:0 });

        // стабильные шаги
        world.integrationParameters.dt = 1/240;
        world.integrationParameters.maxVelocityIterations = 8;
        world.integrationParameters.maxPositionIterations = 3;
        world.integrationParameters.allowedLinearError = 0.001;

        // Ground: наклонная плоскость (тонкий cuboid)
        const groundBody = world.createRigidBody(RAPIER.RigidBodyDesc.fixed());
        const groundCollider = world.createCollider(
          RAPIER.ColliderDesc.cuboid(boardW/2, 0.05, boardH/2)
            .setFriction(0.6)
            .setRestitution(0.05),
          groundBody
        );
        groundBody.setRotation(quatFromEuler(-Math.PI/2 - deg2rad(tiltDeg), 0, 0), true);

        // Frame walls (physics) — совпадает с визуалом
        function makeWall(px, py, pz, hx, hy, hz, ry=0){
          const rb = world.createRigidBody(
            RAPIER.RigidBodyDesc.fixed()
              .setTranslation(px, py, pz)
              .setRotation(quatFromEuler(0, ry, 0))
          );
          world.createCollider(
            RAPIER.ColliderDesc.cuboid(hx, hy, hz)
              .setFriction(0.6)
              .setRestitution(0.05),
            rb
          );
        }
        makeWall( 0, 2.4/2,  boardH/2-0.2, boardW/2, 2.4/2, 0.6/2, 0);
        makeWall( 0, 2.4/2, -boardH/2+0.2, boardW/2, 2.4/2, 0.6/2, 0);
        makeWall(-boardW/2+0.2, 2.4/2, 0, 0.6/2, 2.4/2, boardH/2, Math.PI/2);
        makeWall( boardW/2-0.2, 2.4/2, 0, 0.6/2, 2.4/2, boardH/2, Math.PI/2);

        // Guard walls (невидимые, по периметру, высокая «коробка»)
        const guardH = 4.0, guardT = 0.4;
        makeWall( 0, guardH/2,  boardH/2+0.4, boardW/2+0.6, guardH/2, guardT/2, 0);
        makeWall( 0, guardH/2, -boardH/2-0.8, boardW/2+0.6, guardH/2, guardT/2, 0);
        makeWall(-boardW/2-0.6, guardH/2, 0, guardT/2, guardH/2, boardH/2+1.0, 0);
        makeWall( boardW/2+0.6, guardH/2, 0, guardT/2, guardH/2, boardH/2+1.0, 0);

        // Pins = физические СФЕРЫ (стабильно)
        const pinRadius = 0.21;
        for (let r=0; r<rows; r++){
          const cols = Math.floor(boardW/colGap)+1;
          for (let c=0; c<cols; c++){
            const offset = (r%2===0)?0:colGap/2;
            const x = -boardW/2 + offset + c*colGap;
            const z = boardH/2 - 2 - r*rowGap;
            const rb = world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(x, pinH/2, z));
            world.createCollider(
              RAPIER.ColliderDesc.ball(pinRadius).setFriction(0.5).setRestitution(0.05),
              rb
            );
          }
        }

        // Slot dividers physics
        for (let s=0; s<=slotCount; s++){
          const x = -boardW/2 + s*slotWidth;
          const rb = world.createRigidBody(
            RAPIER.RigidBodyDesc.fixed()
              .setTranslation(x, 1.6/2, slotZ)
              .setRotation(quatFromEuler(0, Math.PI/2, 0))
          );
          world.createCollider(
            RAPIER.ColliderDesc.cuboid(0.6/2, 1.6/2, 0.34/2).setFriction(0.6).setRestitution(0.05),
            rb
          );
        }

        // Catcher physics (floor)
        (function addCatcher(){
          const depth = 3.2, h=0.24;
          const rb = world.createRigidBody(
            RAPIER.RigidBodyDesc.fixed()
              .setTranslation(0, h/2, slotZ - depth/2 - 0.05)
          );
          world.createCollider(
            RAPIER.ColliderDesc.cuboid((boardW-0.5)/2, h/2, depth/2).setFriction(0.8),
            rb
          );
        })();
      }

      function spawnBall(color){
        const id = nextId++;

        // visual
        const radius = 0.22;
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(radius, 32, 32),
          new THREE.MeshPhysicalMaterial({ color, roughness:0.26, metalness:0.08, clearcoat:0.7, clearcoatRoughness:0.25 })
        );
        mesh.castShadow = mesh.receiveShadow = true;
        scene.add(mesh);

        // physics (CCD ON)
        const rb = world.createRigidBody(
          RAPIER.RigidBodyDesc.dynamic()
            .setTranslation((Math.random()-0.5)*(boardW*0.55), 2.6, boardH/2 - 1.0 - Math.random()*0.3)
            .setLinearDamping(0.03)
            .setAngularDamping(0.03)
            .setCcdEnabled(true)
        );
        world.createCollider(
          RAPIER.ColliderDesc.ball(radius)
            .setFriction(0.35)
            .setRestitution(0.12),
          rb
        );

        balls.push({ id, rb, radius, mesh, color, finished:false, prevZ: rb.translation().z });
        renderLB();
      }

      function stabilizeBall(b){
        const v = b.rb.linvel();
        const speed = Math.hypot(v.x, v.y, v.z);
        // микро-пинок если застрял среди пинов
        const p = b.rb.translation();
        if (speed < 0.04 && p.z > slotZ-4 && p.z < boardH/2 && p.y > 0.15){
          b.rb.setLinvel({ x: v.x + (Math.random()-0.5)*0.10, y: v.y, z: v.z + (Math.random()-0.6)*0.06 }, true);
        }
        // ограничение скорости
        const maxV = 4.5;
        if (speed > maxV){
          const k = maxV / speed;
          b.rb.setLinvel({ x: v.x*k, y: v.y*k, z: v.z*k }, true);
        }
      }

      function tickPhysics(dt){
        // Rapier использует фиксированный dt из integrationParameters.dt
        // поэтому просто делаем несколько шагов, чтобы "догнать" реальное время.
        world.step();
      }

      function animate(){
        requestAnimationFrame(animate);

        // несколько маленьких шагов (1/240) дадут супер стабильность
        tickPhysics();

        for (const b of balls){
          stabilizeBall(b);

          const t = b.rb.translation();
          const q = b.rb.rotation();

          b.mesh.position.set(t.x, t.y, t.z);
          b.mesh.quaternion.set(q.x, q.y, q.z, q.w);

          // финиш — пересечение finishZ сверху вниз
          if (!b.finished && b.prevZ > finishZ && t.z <= finishZ){
            b.finished = true;
            const tSec = (performance.now() - startTime)/1000;
            finished.push({ id:b.id, color:b.color, tSec });
            renderLB();
          }
          b.prevZ = t.z;

          // страховка — вернуть в лоток, если "куда-то улетел"
          if (t.y < -2){
            b.rb.setTranslation({ x:0, y:0.3, z: finishZ-0.5 }, true);
            b.rb.setLinvel({ x:0, y:0, z:0 }, true);
            b.rb.setAngvel({ x:0, y:0, z:0 }, true);
          }
        }

        if (controls) controls.update();
        renderer.render(scene, camera);
      }

      // ---------- UI ----------
      document.getElementById('drop').onclick = ()=>{
        finished.length = 0; startTime = performance.now();
        for (let i=0;i<10;i++) spawnBall(colors[i%colors.length]);
      };
      document.getElementById('reset').onclick = ()=>{
        // удалить все шары
        for (const b of balls){
          scene.remove(b.mesh);
          // В Rapier нужно удалить коллайдеры/тело (упрощённо — пересоздадим мир)
        }
        balls.length = 0;
        finished.length = 0; renderLB();

        // Пересоздаём мир для чистоты
        makeWorld();
      };

      // ---------- Init Rapier (async) ----------
      RAPIER.init().then(()=>{
        makeWorld();
        renderLB();
        animate();
      });

      // ---------- Resize ----------
      addEventListener('resize', ()=>{
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
      });
    })();
  </script>
</body>
</html>
