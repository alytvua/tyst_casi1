<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Plinko — Semi-3D (Stable No-Module)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f172a;overflow:hidden}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
      font:600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#e8eefb;z-index:10}
    .btn{background:#1a2333;color:#e8eefb;border:1px solid #2b3d5c;padding:10px 14px;border-radius:12px;cursor:pointer}
    .tag{padding:8px 12px;border-radius:999px;background:#121a27;border:1px solid #2b3d5c}
    .legend{display:flex;gap:8px;align-items:center}
    .dot{width:14px;height:14px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    #seed{width:140px;background:#0f1624;color:#e8eefb;border:1px solid #2b3d5c;border-radius:10px;padding:9px 10px}
    #dbg{position:fixed;left:12px;top:12px;color:#b8c7ff;font:12px/1.3 ui-sans-serif;opacity:.75}
  </style>
</head>
<body>
  <div id="dbg">init…</div>

  <div id="ui">
    <button id="drop" class="btn">Drop 10 Balls</button>
    <button id="reset" class="btn">Reset</button>
    <span class="tag">Tilt: <span id="tiltVal">12°</span></span>
    <input id="seed" placeholder="seed (optional)" />
    <div class="legend tag">
      <span>Bet:</span>
      <span class="dot" style="background:#ff4d4d"></span><span>Red</span>
      <span class="dot" style="background:#5dd9ff"></span><span>Blue</span>
      <span class="dot" style="background:#7cff6b"></span><span>Green</span>
      <span class="dot" style="background:#ffd166"></span><span>Yellow</span>
      <span class="dot" style="background:#d291ff"></span><span>Purple</span>
    </div>
  </div>

  <!-- Проверенные версии БЕЗ модулей -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <script>
    const dbg = document.getElementById('dbg');
    const log = (t)=>{ dbg.textContent = t; console.log(t); };

    // ---------- Renderer ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0f172a, 1);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // ---------- Camera ----------
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 26, 14);

    // ---------- Controls (безопасный фолбэк) ----------
    let controls = null;
    if (THREE && typeof THREE.OrbitControls === 'function') {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.enablePan = false;
      controls.target.set(0,0,0); controls.update();
      log('OrbitControls: OK');
    } else {
      // Статичная камера, но всё работает
      camera.lookAt(0,0,0);
      log('OrbitControls: MISSING (using static camera)');
    }

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(12, 24, 12); key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x9bbcff, 0.5);
    rim.position.set(-10, 16, -12); scene.add(rim);

    // ---------- Physics ----------
    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    const defaultMat = new CANNON.Material("default");
    const contact = new CANNON.ContactMaterial(defaultMat, defaultMat, { friction:0.16, restitution:0.4 });
    world.addContactMaterial(contact);
    world.defaultContactMaterial = contact;

    // ---------- Board ----------
    const boardW = 14, boardH = 22;
    const board = new THREE.Mesh(
      new THREE.PlaneGeometry(boardW, boardH),
      new THREE.MeshStandardMaterial({
        color:0x263043, metalness:0.25, roughness:0.55,
        emissive:0x0b1120, emissiveIntensity:0.15
      })
    );
    board.rotation.x = -Math.PI/2;
    board.receiveShadow = true;
    scene.add(board);

    const tiltDeg = 12; document.getElementById('tiltVal').textContent = tiltDeg + "°";
    const boardBody = new CANNON.Body({ mass:0, material:defaultMat });
    boardBody.addShape(new CANNON.Plane());
    const deg2rad = d => d * Math.PI / 180;
    boardBody.quaternion.setFromEuler(-deg2rad(tiltDeg), 0, 0, 'XYZ'); // наклон вперёд
    world.addBody(boardBody);

    // ---------- Walls ----------
    function addWall(x, z, w, t, rotY=0){
      const h = 1.2;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, t),
        new THREE.MeshStandardMaterial({ color:0x1b2436, metalness:0.3, roughness:0.45 })
      );
      mesh.position.set(x, h/2, z); mesh.rotation.y = rotY;
      mesh.castShadow = mesh.receiveShadow = true;
      scene.add(mesh);

      const body = new CANNON.Body({ mass:0, material:defaultMat });
      body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, t/2)));
      body.position.set(x, h/2, z);
      const q = new CANNON.Quaternion(); q.setFromEuler(0, rotY, 0, 'XYZ');
      body.quaternion.copy(q);
      world.addBody(body);
    }
    addWall( 0,  boardH/2-0.2, boardW, 0.4, 0);
    addWall( 0, -boardH/2+0.2, boardW, 0.4, 0);
    addWall(-boardW/2+0.2, 0, boardH, 0.4, Math.PI/2);
    addWall( boardW/2-0.2, 0, boardH, 0.4, Math.PI/2);

    // ---------- Pins ----------
    const pinR = 0.17, pinH = 0.6, rowGap = 1.0, colGap = 1.0, rows = 14;
    const pinGeo = new THREE.CylinderGeometry(pinR, pinR, pinH, 20);
    const pinMat = new THREE.MeshStandardMaterial({ color:0x2f3b59, metalness:0.6, roughness:0.35 });

    for (let r=0; r<rows; r++){
      const cols = Math.floor(boardW/colGap) + 1;
      for (let c=0; c<cols; c++){
        const offset = (r%2===0) ? 0 : colGap/2;
        const x = -boardW/2 + offset + c*colGap;
        const z = boardH/2 - 2 - r*rowGap;
        const y = pinH/2;

        const m = new THREE.Mesh(pinGeo, pinMat);
        m.position.set(x, y, z);
        m.castShadow = m.receiveShadow = true;
        scene.add(m);

        const body = new CANNON.Body({ mass:0, material:defaultMat });
        const shape = new CANNON.Cylinder(pinR, pinR, pinH, 12);
        body.addShape(shape);
        body.position.set(x, y, z);
        const q = new CANNON.Quaternion(); q.setFromEuler(Math.PI/2, 0, 0, 'XYZ');
        body.quaternion.copy(q);
        world.addBody(body);
      }
    }

    // ---------- Slots ----------
    const slotCount = 7, slotWidth = boardW / slotCount, slotZ = -boardH/2 + 0.6;
    for (let s=0; s<=slotCount; s++){
      const x = -boardW/2 + s*slotWidth;
      addWall(x, slotZ, 0.25, 0.4, Math.PI/2);
    }

    // ---------- Balls ----------
    const colors = [0xff4d4d, 0x5dd9ff, 0x7cff6b, 0xffd166, 0xd291ff];
    const ballR = 0.22;
    const balls = [];

    function spawnBall(color){
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(ballR, 32, 32),
        new THREE.MeshPhysicalMaterial({
          color, roughness:0.2, metalness:0.1, clearcoat:0.7, clearcoatRoughness:0.25
        })
      );
      mesh.castShadow = mesh.receiveShadow = true;
      scene.add(mesh);

      const body = new CANNON.Body({
        mass:0.16, material:defaultMat,
        shape:new CANNON.Sphere(ballR),
        linearDamping:0.01, angularDamping:0.01
      });
      body.position.set((Math.random()-0.5)*(boardW*0.6), 4.0, boardH/2 - 1.0);
      world.addBody(body);

      balls.push({ mesh, body });
    }

    // ---------- UI ----------
    document.getElementById('drop').onclick = ()=>{
      for (let i=0; i<10; i++) spawnBall(colors[i % colors.length]);
    };
    document.getElementById('reset').onclick = ()=>{
      balls.forEach(b => { scene.remove(b.mesh); world.removeBody(b.body); });
      balls.length = 0;
    };

    // ---------- Loop ----------
    const clock = new THREE.Clock();
    (function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 1/30);
      world.step(1/60, dt, 8);
      for (const b of balls){
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
      }
      if (controls) controls.update();
      renderer.render(scene, camera);
    })();

    // ---------- Resize ----------
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // Лог ошибок в уголок
    window.addEventListener('error', e => log('Error: ' + e.message));
    log('Ready');
  </script>
</body>
</html>
