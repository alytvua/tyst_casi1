<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Plinko — Semi-3D</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f172a;overflow:hidden}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
      font:600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#e8eefb}
    .btn{background:#1a2333;color:#e8eefb;border:1px solid #2b3d5c;padding:10px 14px;border-radius:12px;cursor:pointer}
    .tag{padding:8px 12px;border-radius:999px;background:#121a27;border:1px solid #2b3d5c}
    .legend{display:flex;gap:8px;align-items:center}
    .dot{width:14px;height:14px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    #seed{width:140px;background:#0f1624;color:#e8eefb;border:1px solid #2b3d5c;border-radius:10px;padding:9px 10px}
  </style>
</head>
<body>
  <div id="ui">
    <button id="drop" class="btn">Drop 10 Balls</button>
    <button id="reset" class="btn">Reset</button>
    <span class="tag">Tilt: <span id="tiltVal">12°</span></span>
    <input id="seed" placeholder="seed (optional)" />
    <div class="legend tag">
      <span>Bet:</span>
      <span class="dot" style="background:#ff4d4d"></span><span>Red</span>
      <span class="dot" style="background:#5dd9ff"></span><span>Blue</span>
      <span class="dot" style="background:#7cff6b"></span><span>Green</span>
      <span class="dot" style="background:#ffd166"></span><span>Yellow</span>
      <span class="dot" style="background:#d291ff"></span><span>Purple</span>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/OrbitControls.js";
    import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.20/dist/cannon-es.js";

    // --- renderer / color ---
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0f172a, 1);                // фон не чёрный
    renderer.shadowMap.enabled = true;
    THREE.ColorManagement.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // --- camera ---
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 26, 14);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.target.set(0, 0, 0);                       // важный фикс: цель камеры
    controls.update();

    // --- lights (ярче) ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(12, 24, 12);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x9bbcff, 0.5);
    rim.position.set(-10, 16, -12);
    scene.add(rim);

    // --- physics world ---
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
    const defaultMat = new CANNON.Material("default");
    const contact = new CANNON.ContactMaterial(defaultMat, defaultMat, { friction:0.16, restitution:0.4 });
    world.addContactMaterial(contact);
    world.defaultContactMaterial = contact;

    // --- board (видимая и физическая) ---
    const boardW = 14, boardH = 22;
    const boardGeo = new THREE.PlaneGeometry(boardW, boardH);
    const boardMat = new THREE.MeshStandardMaterial({
      color: 0x263043, metalness: 0.25, roughness: 0.55, emissive: 0x0b1120, emissiveIntensity: 0.15
    });
    const board = new THREE.Mesh(boardGeo, boardMat);
    board.rotation.x = -Math.PI/2;
    board.receiveShadow = true;
    scene.add(board);

    const tiltDeg = 12;
    document.getElementById('tiltVal').textContent = tiltDeg + "°";
    const boardBody = new CANNON.Body({ mass:0, shape:new CANNON.Plane(), material:defaultMat });
    boardBody.quaternion.setFromEuler(THREE.MathUtils.degToRad(-tiltDeg), 0, 0);
    world.addBody(boardBody);

    // --- walls ---
    function addWall(x, z, w, t, rotY=0){
      const h = 1.2;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, t),
        new THREE.MeshStandardMaterial({ color:0x1b2436, metalness:0.3, roughness:0.45 })
      );
      mesh.position.set(x, h/2, z); mesh.rotation.y = rotY; mesh.castShadow = mesh.receiveShadow = true;
      scene.add(mesh);

      const body = new CANNON.Body({ mass:0, material:defaultMat });
      body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, t/2)));
      body.position.set(x, h/2, z);
      body.quaternion.setFromEuler(0, rotY, 0);
      world.addBody(body);
    }
    addWall( 0,  boardH/2-0.2, boardW, 0.4, 0);
    addWall( 0, -boardH/2+0.2, boardW, 0.4, 0);
    addWall(-boardW/2+0.2, 0, boardH, 0.4, Math.PI/2);
    addWall( boardW/2-0.2, 0, boardH, 0.4, Math.PI/2);

    // --- pins ---
    const pinR = 0.17, pinH = 0.6, rowGap = 1.0, colGap = 1.0, rows = 14;
    const pinGeo = new THREE.CylinderGeometry(pinR, pinR, pinH, 20);
    const pinMat = new THREE.MeshStandardMaterial({ color:0x2f3b59, metalness:0.6, roughness:0.35 });
    const colsBase = Math.floor(boardW/colGap) + 1;
    const inst = new THREE.InstancedMesh(pinGeo, pinMat, rows*colsBase);
    inst.castShadow = inst.receiveShadow = true;
    scene.add(inst);
    let idx=0;
    for(let r=0;r<rows;r++){
      const cols = colsBase;
      for(let c=0;c<cols;c++){
        const offset = (r%2===0)?0:colGap/2;
        const x = -boardW/2 + offset + c*colGap;
        const z = boardH/2 - 2 - r*rowGap;
        const y = pinH/2;
        inst.setMatrixAt(idx++, new THREE.Matrix4().makeTranslation(x,y,z));

        const body = new CANNON.Body({ mass:0, material:defaultMat });
        body.addShape(new CANNON.Cylinder(pinR, pinR, pinH, 14));
        body.position.set(x,y,z);
        body.quaternion.setFromEuler(Math.PI/2,0,0);
        world.addBody(body);
      }
    }
    inst.instanceMatrix.needsUpdate = true;

    // --- slots ---
    const slotCount = 7, slotWidth = boardW/slotCount, slotZ = -boardH/2 + 0.6;
    for(let s=0;s<=slotCount;s++){
      const x = -boardW/2 + s*slotWidth;
      addWall(x, slotZ, 0.25, 0.4, Math.PI/2);
    }

    // --- balls ---
    const colors = [0xff4d4d, 0x5dd9ff, 0x7cff6b, 0xffd166, 0xd291ff];
    const ballR = 0.22;
    const ballGeo = new THREE.SphereGeometry(ballR, 32, 32);
    const balls = [];

    function spawnBall(color){
      const mesh = new THREE.Mesh(ballGeo, new THREE.MeshPhysicalMaterial({
        color, roughness:0.2, metalness:0.1, clearcoat:0.7, clearcoatRoughness:0.25
      }));
      mesh.castShadow = mesh.receiveShadow = true;
      scene.add(mesh);

      const body = new CANNON.Body({
        mass:0.16, shape:new CANNON.Sphere(ballR), material:defaultMat,
        linearDamping:0.01, angularDamping:0.01
      });
      body.position.set((Math.random()-0.5)*(boardW*0.6), 4.0, boardH/2-1.0);
      world.addBody(body);

      balls.push({mesh, body});
    }

    // --- UI ---
    document.getElementById('drop').onclick = ()=>{ for(let i=0;i<10;i++) spawnBall(colors[i%colors.length]); };
    document.getElementById('reset').onclick = ()=>{
      balls.forEach(b=>{ scene.remove(b.mesh); world.removeBody(b.body); });
      balls.length = 0;
    };

    // --- loop ---
    const clock = new THREE.Clock();
    (function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 1/30);
      world.step(1/60, dt, 8);
      for(const b of balls){
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
      }
      controls.update();
      renderer.render(scene, camera);
    })();

    // --- resize ---
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
