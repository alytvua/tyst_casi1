<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Plinko — Stable Physics + Leaderboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0f172a;overflow:hidden}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
      font:600 14px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:#e8eefb;z-index:10}
    .btn{background:#1a2333;color:#e8eefb;border:1px solid #2b3d5c;padding:10px 14px;border-radius:12px;cursor:pointer}
    .tag{padding:8px 12px;border-radius:999px;background:#121a27;border:1px solid #2b3d5c}
    .legend{display:flex;gap:8px;align-items:center}
    .dot{width:14px;height:14px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    #seed{width:140px;background:#0f1624;color:#e8eefb;border:1px solid #2b3d5c;border-radius:10px;padding:9px 10px}
    #hud{position:fixed;right:12px;top:12px;z-index:11;color:#e8eefb;font:600 14px/1.35 ui-sans-serif,system-ui,Segoe UI,Roboto}
    .card{background:#0f1624cc;border:1px solid #2b3d5c;padding:10px 12px;border-radius:12px;min-width:220px}
    .row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .swatch{width:12px;height:12px;border-radius:50%;border:1px solid rgba(255,255,255,.6)}
    .muted{opacity:.75;font-weight:500}
  </style>
</head>
<body>
  <div id="hud" class="card">
    <div class="row"><strong>Leaderboard</strong></div>
    <div id="lb"></div>
    <div class="row muted">In progress: <span id="left">0</span></div>
  </div>

  <div id="ui">
    <button id="drop" class="btn">Drop 10 Balls</button>
    <button id="reset" class="btn">Reset</button>
    <span class="tag">Tilt: <span id="tiltVal">12°</span></span>
    <input id="seed" placeholder="seed (optional)" />
    <div class="legend tag">
      <span>Bet:</span>
      <span class="dot" style="background:#ff4d4d"></span><span>Red</span>
      <span class="dot" style="background:#5dd9ff"></span><span>Blue</span>
      <span class="dot" style="background:#7cff6b"></span><span>Green</span>
      <span class="dot" style="background:#ffd166"></span><span>Yellow</span>
      <span class="dot" style="background:#d291ff"></span><span>Purple</span>
    </div>
  </div>

  <!-- Глобальные версии без модулей -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>

  <script>
    // ---------- renderer ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0f172a, 1);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    const scene = new THREE.Scene();

    // ---------- camera ----------
    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 300);
    camera.position.set(0, 36, 28);
    let controls=null;
    if(typeof THREE.OrbitControls==='function'){
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.enablePan=false;
      controls.minDistance=24; controls.maxDistance=50;
      controls.minPolarAngle=THREE.Math.degToRad(30);
      controls.maxPolarAngle=THREE.Math.degToRad(65);
      controls.target.set(0,0,0); controls.update();
    }else{ camera.lookAt(0,0,0); }

    // ---------- lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const key = new THREE.DirectionalLight(0xffffff, 1.15);
    key.position.set(12, 26, 12); key.castShadow = true; key.shadow.mapSize.set(2048,2048);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x9bbcff, 0.5);
    rim.position.set(-10, 18, -12); scene.add(rim);

    // ---------- physics ----------
    const world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 30;     // ещё стабильнее контакты
    world.solver.tolerance = 0.0005;

    const defaultMat = new CANNON.Material("default");
    const contact = new CANNON.ContactMaterial(defaultMat, defaultMat, {
      friction: 0.32,
      restitution: 0.12
    });
    world.addContactMaterial(contact);
    world.defaultContactMaterial = contact;

    // ---------- board ----------
    const boardW = 14, boardH = 22;
    const board = new THREE.Mesh(
      new THREE.PlaneGeometry(boardW, boardH),
      new THREE.MeshStandardMaterial({ color:0x263043, metalness:0.25, roughness:0.55, emissive:0x0b1120, emissiveIntensity:0.15 })
    );
    board.rotation.x = -Math.PI/2; board.receiveShadow = true; scene.add(board);

    const tiltDeg = 12; document.getElementById('tiltVal').textContent = tiltDeg + "°";
    const deg2rad = d=>d*Math.PI/180;

    const boardBody = new CANNON.Body({ mass:0, material:defaultMat });
    boardBody.addShape(new CANNON.Plane());
    boardBody.quaternion.setFromEuler(-Math.PI/2 - deg2rad(tiltDeg), 0, 0, 'XYZ'); // горизонтально + наклон
    world.addBody(boardBody);

    // ---------- walls (большие ограничители по периметру) ----------
    function addWallBox(x, y, z, sx, sy, sz){
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(sx, sy, sz),
        new THREE.MeshStandardMaterial({ color:0x1b2436, metalness:0.3, roughness:0.45, transparent:true, opacity:0.999 })
      );
      mesh.position.set(x,y,z); mesh.castShadow=mesh.receiveShadow=true; scene.add(mesh);
      const body = new CANNON.Body({ mass:0, material:defaultMat });
      body.addShape(new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2)));
      body.position.set(x,y,z); world.addBody(body);
    }

    // Рамка видимая (эстетика)
    function addFrameWall(x, z, w, t, rotY=0, h=2.2){
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, t),
        new THREE.MeshStandardMaterial({ color:0x1b2436, metalness:0.3, roughness:0.45 })
      );
      mesh.position.set(x, h/2, z); mesh.rotation.y=rotY; mesh.castShadow=mesh.receiveShadow=true; scene.add(mesh);
      const body = new CANNON.Body({ mass:0, material:defaultMat });
      body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, t/2)));
      body.position.set(x, h/2, z);
      const q=new CANNON.Quaternion(); q.setFromEuler(0, rotY, 0, 'XYZ'); body.quaternion.copy(q);
      world.addBody(body);
    }
    addFrameWall( 0,  boardH/2-0.2, boardW, 0.6, 0, 2.4);
    addFrameWall( 0, -boardH/2+0.2, boardW, 0.6, 0, 2.4);
    addFrameWall(-boardW/2+0.2, 0, boardH, 0.6, Math.PI/2, 2.4);
    addFrameWall( boardW/2-0.2, 0, boardH, 0.6, Math.PI/2, 2.4);

    // ДОП. НЕВИДИМЫЕ СТЕНЫ на всю высоту, чтобы шары никогда не улетали за поле
    const guardH = 4.0, guardT = 0.4;
    // передняя/задняя
    addWallBox(0, guardH/2,  boardH/2+0.4, boardW+1.2, guardH, guardT);
    addWallBox(0, guardH/2, -boardH/2-0.8, boardW+1.2, guardH, guardT);
    // левая/правая
    addWallBox(-boardW/2-0.6, guardH/2, 0, guardT, guardH, boardH+2.0);
    addWallBox( boardW/2+0.6, guardH/2, 0, guardT, guardH, boardH+2.0);

    // ---------- pins (ФИЗИКА = СФЕРЫ; визуал остаётся цилиндрами) ----------
    const pinR_draw = 0.19, pinH = 0.62;     // видимый цилиндр
    const pinR_phys = 0.21;                  // физический шар — чуть больше
    const rowGap = 1.0, colGap = 1.0, rows = 14;
    const pinGeo = new THREE.CylinderGeometry(pinR_draw, pinR_draw, pinH, 20);
    const pinMat = new THREE.MeshStandardMaterial({ color:0x2f3b59, metalness:0.6, roughness:0.35 });

    for(let r=0;r<rows;r++){
      const cols = Math.floor(boardW/colGap)+1;
      for(let c=0;c<cols;c++){
        const offset = (r%2===0)?0:colGap/2;
        const x = -boardW/2 + offset + c*colGap;
        const z = boardH/2 - 2 - r*rowGap;
        const y = pinH/2;

        // видимый цилиндр
        const m = new THREE.Mesh(pinGeo, pinMat);
        m.position.set(x,y,z); m.castShadow=m.receiveShadow=true; scene.add(m);

        // физическое тело — СФЕРА (стабильнее контакты)
        const body = new CANNON.Body({ mass:0, material:defaultMat });
        body.addShape(new CANNON.Sphere(pinR_phys));
        body.position.set(x, y, z);
        world.addBody(body);
      }
    }

    // ---------- slots & catcher ----------
    const slotCount = 7;
    const slotWidth = boardW / slotCount;
    const slotZ = -boardH/2 + 0.6;

    // перегородки (видимые + физика)
    for(let s=0;s<=slotCount;s++){
      const x = -boardW/2 + s*slotWidth;
      addFrameWall(x, slotZ, 0.34, 0.6, Math.PI/2, 1.6);
    }
    // Нижний лоток-ловушка (шире/глубже)
    (function addCatcher(){
      const depth = 3.2, h=0.24;
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(boardW-0.5, h, depth),
        new THREE.MeshStandardMaterial({ color:0x1a2234, metalness:0.2, roughness:0.6 }));
      mesh.position.set(0, h/2, slotZ - depth/2 - 0.05); mesh.castShadow=mesh.receiveShadow=true; scene.add(mesh);
      const body = new CANNON.Body({ mass:0, material:defaultMat });
      body.addShape(new CANNON.Box(new CANNON.Vec3((boardW-0.5)/2, h/2, depth/2)));
      body.position.copy(mesh.position); world.addBody(body);
    })();

    // ---------- finish line ----------
    const finishZ = slotZ - 0.25;
    const fGeo = new THREE.BoxGeometry(boardW-0.6, 0.05, 0.02);
    const fMat = new THREE.MeshBasicMaterial({ color:0x29ff89 });
    const finishLine = new THREE.Mesh(fGeo, fMat);
    finishLine.position.set(0, 0.51, finishZ);
    scene.add(finishLine);

    // ---------- balls & leaderboard ----------
    const colors = [0xff4d4d, 0x5dd9ff, 0x7cff6b, 0xffd166, 0xd291ff];
    const colorName = { [0xff4d4d]:'Red', [0x5dd9ff]:'Blue', [0x7cff6b]:'Green', [0xffd166]:'Yellow', [0xd291ff]:'Purple' };
    const ballR = 0.22;
    const balls = [];
    let startTime = 0;
    const finished = [];
    const lbEl = document.getElementById('lb');
    const leftEl = document.getElementById('left');
    let nextId = 1;

    function renderLB(){
      lbEl.innerHTML = '';
      finished.sort((a,b)=>a.tSec-b.tSec).forEach((e,i)=>{
        const row = document.createElement('div');
        row.className='row';
        row.innerHTML=`<span>${i+1}.</span>
          <span class="swatch" style="background:#${e.color.toString(16).padStart(6,'0')}"></span>
          <span>${colorName[e.color]||('#'+e.color.toString(16))}</span>
          <span class="muted">${e.tSec.toFixed(2)}s</span>`;
        lbEl.appendChild(row);
      });
      leftEl.textContent = balls.filter(b=>!b.finished).length;
    }

    function spawnBall(color){
      const id = nextId++;
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(ballR, 32, 32),
        new THREE.MeshPhysicalMaterial({ color, roughness:0.26, metalness:0.08, clearcoat:0.7, clearcoatRoughness:0.25 })
      );
      mesh.castShadow=mesh.receiveShadow=true; scene.add(mesh);

      const body = new CANNON.Body({
        mass:0.18, material:defaultMat,
        shape:new CANNON.Sphere(ballR),
        linearDamping:0.03, angularDamping:0.03
      });
      body.position.set((Math.random()-0.5)*(boardW*0.55), 2.6, boardH/2 - 1.0 - Math.random()*0.3);
      world.addBody(body);

      balls.push({ id, mesh, body, color, finished:false, prevZ: body.position.z });
      renderLB();
    }

    // Анти-застревание + ограничение скорости (ещё сильнее)
    function stabilizeBall(b){
      const v = b.body.velocity;
      const speed = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);

      // мягкий пинок в зоне пинов
      if (speed < 0.04 && b.body.position.z > slotZ-4 && b.body.position.z < boardH/2 && b.body.position.y > 0.15){
        b.body.velocity.x += (Math.random()-0.5)*0.10;
        b.body.velocity.z += (Math.random()-0.6)*0.06;
      }

      // ограничение скорости — меньше туннелинга
      const maxV = 4.2;
      if (speed > maxV){
        const scale = maxV / speed;
        b.body.velocity.scale(scale, b.body.velocity);
      }
    }

    // ---------- UI ----------
    document.getElementById('drop').onclick = ()=>{
      finished.length = 0; startTime = performance.now();
      for(let i=0;i<10;i++) spawnBall(colors[i%colors.length]);
    };
    document.getElementById('reset').onclick = ()=>{
      balls.forEach(b=>{ scene.remove(b.mesh); world.removeBody(b.body); });
      balls.length = 0; finished.length = 0; renderLB();
    };

    // ---------- loop (частый фикс-шаг) ----------
    const clock = new THREE.Clock();
    let accumulator = 0;
    const fixedStep = 1/240;     // маленький шаг
    (function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      accumulator += dt;
      // несколько маленьких шагов подряд
      while (accumulator >= fixedStep){
        world.step(fixedStep);
        accumulator -= fixedStep;
      }

      for (const b of balls){
        stabilizeBall(b);

        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);

        // финиш — пересечение линии сверху вниз
        if (!b.finished && b.prevZ > finishZ && b.body.position.z <= finishZ){
          b.finished = true;
          const tSec = (performance.now() - startTime)/1000;
          finished.push({ id:b.id, color:b.color, tSec });
          renderLB();
        }
        b.prevZ = b.body.position.z;

        // страховка от выпадения (возвращаем в лоток)
        if (b.body.position.y < -2){
          b.body.velocity.set(0,0,0);
          b.body.angularVelocity.set(0,0,0);
          b.body.position.set(0,0.3, finishZ-0.5);
        }
      }

      if (controls) controls.update();
      renderer.render(scene, camera);
    })();

    // ---------- resize ----------
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
